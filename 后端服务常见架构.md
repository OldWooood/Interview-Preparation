## 一、单体架构（Monolithic Architecture）

**特点：**

* 整个系统是一个整体，所有模块都在同一个进程里。
* 开发简单、部署方便，但随着规模增大会变得难以维护和扩展。

**适用场景：** 初创项目、业务简单的小型系统。

**示例：**

* 一个电商网站，用户、商品、订单、支付模块都打包在一个 Spring Boot 应用里。
* Django / Rails 早期常见的“胖应用”。

---

## 二、分层架构（Layered Architecture）

**特点：**

* 最典型的“三层/四层架构”：表示层（UI）、业务层（Service）、数据层（DAO）、数据库。
* 职责清晰，利于维护和理解。

**适用场景：** 传统企业应用、后台管理系统。

**示例：**

* Java EE 的三层架构：Controller → Service → Repository → MySQL。
* .NET MVC 应用。

---

## 三、SOA（Service-Oriented Architecture，面向服务架构）

**特点：**

* 系统拆分成多个业务服务，通过 ESB（企业服务总线）或 RPC 进行通信。
* 强调“服务复用”，但过度依赖 ESB 可能成为单点瓶颈。

**适用场景：** 企业级应用、政府/银行系统。

**示例：**

* 银行系统：账户服务、交易服务、风控服务，通过 WebService/ESB 对接。
* 早期的 Dubbo（RPC 框架）在很多公司中属于 SOA 形态。

---

## 四、微服务架构（Microservices Architecture）

**特点：**

* 将系统拆分为小而独立的服务，每个服务独立部署和扩展。
* 服务间通过轻量级通信（HTTP/gRPC/Kafka）协作。
* 强调自治、DevOps、容器化（Docker/K8s）。

**优点：** 灵活扩展，适合大规模并发和快速迭代。
**缺点：** 服务治理复杂，需要配套监控、日志、配置中心等。

**适用场景：** 大型互联网应用、电商、金融科技。

**示例：**

* 京东/淘宝：商品服务、订单服务、库存服务、支付服务，各自独立。
* Netflix：独立的用户、推荐、视频转码服务，通过 API Gateway 统一对外。

---

## 五、Serverless 架构（无服务器架构）

**特点：**

* 开发者只写函数逻辑，运行环境由云平台托管（AWS Lambda、阿里云函数计算）。
* 按需计算、弹性伸缩，不需要管理服务器。

**适用场景：** 短任务、事件驱动型应用（比如图片处理、定时任务、消息消费）。

**示例：**

* 上传图片 → 触发 Lambda → 压缩图片并存储到 S3。
* 微信小程序的云函数。

---

## 六、事件驱动架构（Event-Driven Architecture）

**特点：**

* 以消息/事件为核心，服务之间通过消息队列（Kafka、RabbitMQ、RocketMQ）解耦。
* 天然支持异步、削峰填谷。

**适用场景：** 需要高并发、异步处理的业务场景。

**示例：**

* 电商下单 → 产生“订单已创建”事件 → 消费者服务异步扣库存、发送短信。
* 交易平台：撮合引擎发布交易事件，通知清算系统。

---

## 七、分布式架构（Distributed Systems）

**特点：**

* 服务和数据分布在多台机器上，强调高可用、容错、扩展性。
* 包含 CAP 定理的权衡。

**常见模式：**

* 分布式缓存（Redis Cluster、Memcached）。
* 分布式数据库（MySQL Sharding、CockroachDB）。
* 分布式存储（HDFS、Ceph）。

**示例：**

* 电商大促：订单服务水平拆分，分布式锁控制超卖。
* 支付宝：跨地域多活架构，保证高可用。

---

## 八、混合架构（多种模式结合）

**特点：**

* 实际工程中常常是多种架构的组合，比如“微服务 + 事件驱动 + Serverless 辅助”。

**示例：**

* 电商平台：核心业务是微服务，消息流转用事件驱动，大量计算任务用 Serverless。

---
👌 那我帮你整理一个对比表格，把常见的后端服务架构放在一起对比，面试的时候你就能有一个清晰的脉络。

---

## 九、服务架构对比表

| 架构类型                    | 特点                    | 优点                | 缺点                  | 典型场景       | 举例                          |
| ----------------------- | --------------------- | ----------------- | ------------------- | ---------- | --------------------------- |
| **单体架构 (Monolithic)**   | 所有模块打包成一个应用，单进程运行     | 开发简单，部署方便         | 难以扩展，改动影响全局，发布成本高   | 小型系统，初创项目  | 一个 Spring Boot 应用包含用户、订单、支付 |
| **分层架构 (Layered)**      | 按照表现层、业务层、数据层分层       | 职责清晰，易维护，经典设计     | 复杂业务下会层层调用，灵活性不足    | 企业后台系统     | Java EE 三层架构、.NET MVC       |
| **SOA (面向服务架构)**        | 模块拆分为服务，通过 ESB/RPC 连接 | 服务复用，解耦一定程度提高扩展性  | 依赖 ESB，治理成本高，性能瓶颈   | 传统大型企业应用   | 银行系统、早期 Dubbo 架构            |
| **微服务 (Microservices)** | 每个服务独立运行，API/消息通信     | 独立部署，弹性伸缩，适合大规模系统 | 服务治理复杂，需要 DevOps、监控 | 大型互联网、电商   | 淘宝：商品服务、订单服务、支付服务分开         |
| **Serverless (无服务器)**   | 事件驱动，函数级运行，云平台托管      | 按需计费，自动扩缩容，运维压力小  | 冷启动延迟，状态管理复杂        | 事件触发任务、短任务 | AWS Lambda、微信小程序云函数         |
| **事件驱动架构 (EDA)**        | 系统以事件流为核心，通过 MQ 解耦    | 异步解耦、削峰填谷、可扩展     | 调试复杂，事务一致性难         | 高并发、异步业务   | Kafka 驱动的订单异步处理             |
| **分布式架构 (Distributed)** | 系统与数据分布在多台机器上         | 高可用、可扩展、容错        | CAP 权衡复杂，架构难度大      | 高并发、大规模系统  | Redis Cluster、分库分表、HDFS     |
| **混合架构 (Hybrid)**       | 多种架构结合使用              | 优势互补，灵活           | 实现复杂度高              | 大型综合系统     | 微服务 + EDA + Serverless 混合   |

---

📌 **记忆技巧（面试用）**

* **单体 → 分层 → SOA → 微服务 → Serverless/EDA/分布式 → 混合**，这是演进路线。
* 面试时，可以先说“按历史演进”来讲，然后再说“按特点分类”。
* 如果被问到选择理由，可以结合“业务复杂度 + 团队规模 + 运维能力”来回答。